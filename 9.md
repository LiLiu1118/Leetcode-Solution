# 9. Palindrome Number

```c++
class Solution {
public:
    bool isPalindrome(int x) {
        if ((x < 0) || ((x % 10 == 0) && x != 0))
            return false;
        int rev = 0;
        while (x > rev)
        {
            
            rev = rev * 10 + x % 10;
            x = x / 10;
        }
        
        return ((rev / 10 == x) || (rev == x));
    }
};

```

# 思路

累乘法反转数字后半部分，和前半部分进行比较，使用(x > rev)侦测是否到达数字中间位置。

### 1.1 数字位数为偶数

1.1.1 数字为回文数，如1221,当21反转为12的时候，条件不满足然后进行return判断，即得出结果

1.1.2 数字不是回文数，但是后半部分反转后比前半部分大，这样并不影响判断，如1234,当34反转为43的时候，条件不满足，即得出结果

1.1.3 数字不是回文数，但是后半部分反转后比前半部分小，如3412,这样会影响判断，即使已经到了数字中部，还是会继续累乘，这样不影响判断，因为此时前后部分已经相差了两位，就算对十取模也还相差一位，不可能相等

### 1.2 数字位数为奇数

如12321或者12345,此时前后部分位数不可能相等，所以不会因为前后半部分的大小问题影响位数的判断，不管怎么样走到数字中部循环就结束了，此时后半部分肯定位数多一，走出循环，然后对十取模即可得出判断2



